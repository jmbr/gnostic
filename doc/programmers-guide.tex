%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% $Id$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[a4paper,12pt]{book}

\usepackage[latin1]{inputenc}
\usepackage[english]{babel}

\newcommand{\gnostic}{\emph{gnostic} }
\newcommand{\libxml}{\emph{libxml2} }
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\title{gnostic 0.2\\Programmer's guide}
\author{Juan Manuel Bello Rivas}
\maketitle

\pagebreak

\begin{quotation}
\textbf{gnostic:} adjective 1 of knowledge. 2 having special mystic knowledge.
noun (Gnostic) early Christian heretic claiming mystical knowledge.
\end{quotation}

\pagebreak

\tableofcontents

\pagebreak

\chapter{Introduction}

\section{What is \gnostic?}

\gnostic is a flexible, general-purpose network and host penetration tool.

\section{Example scenario}

XXX.

\chapter{Program design}

This section describes the problems solved by \gnostic as well as the
approaches taken to solve them.

The whole program revolves around two concepts: modules and the notepad.

\section{Tasks}

Each task is defined by:

\begin{description}

\item [Name] A unique identifier for the task.

\item [Dependencies] An expression of the tasks's reliance on the success (or
failure) of other tasks which must be executed previously.

\item [Requirements] A small shell script checking for things needed (e.g.:
existence of certain files, etc.) by the task.

\item [Actions] Usually a piece of bash shell script taking information from the
shared information space, doing something useful with it and writing back the
results to the shared database (the notepad).

\end{description}

\section{The notepad}

The notepad is an information space shared by all the modules. It is currently
implemented in the executing host's filesystem.

\begin{figure}[ht]
\begin{verbatim}
/vars
/vars/addr
/vars/root
/ipv4/192/168/1/23/udp/ports
/ipv4/192/168/1/23/udp/ports/53
\end{verbatim}
\caption{Example of the directory hierarchy}
\end{figure}

\section{Implementation goals}

Top goals for the project are:

\begin{description}

\item [Modularity] The program's core size should be kept to a minimum and all
the useful work should be performed by the modules.

\item [Simplicity] The whole implementation should be written with simplicity
and ease of coding in mind.

\item [Transparency] The program exposes its internal data structures to the
modules.

\end{description}

\chapter{Memory management}

Several things should be taken into account when dealing with dynamic memory
allocation in the program. In this section these considerations are summarized
in a per-module basis.

\section{Configuration file parser and compiler}

\subsection{Decoupling from \libxml}

There's a strong emphasis towards decoupling the program from the XML parser
library.  We don't want to have any strings or datastructures laying around in
the code after configuration file parsing has taken place. Not doing this would
result in problems if the XML library is to be changed in the future.

Also, the current XML library (\libxml) has its own dynamic memory
allocator and having to invoke its custom made functions for freeing strings
would result in too much clutter.

For this reason a macro named \code{MOVE\_STR} is provided in \code{conf.c}. It
will copy the strings returned by \libxml and free the originals.

\subsection{Dependency expression compiler}

The lexical analyzer allocates memory for all the identifiers being scanned.
This memory will be kept until the module \code{compiler.c} resolves all names
to their corresponding \code{task} structures. At that point the memory for
these strings is deallocated.

\section{Tasks and scripts}

Parsing the configuration file produces a list of \code{task} structures and
although items from this list are referenced throught the program in several
other containers (a hash table, lists, a graph, etc.) only
\code{delete\_tasklist} is responsible for freeing the memory associated with
each \code{task}.

On the other hand, \code{script}s are tied only to a given \code{task} and so
\code{delete\_task} is in charge of invoking \code{delete\_script} and
deallocating those resources.

\section{Memory debugging}

The program is run periodically through \code{valgrind} and during normal
execution it exits \textbf{without any} memory leaks. Emphasis should be placed
on checking and proactively avoiding these kinds of errors.

\end{document}


% vim: sw=2 ts=2 et filetype=tex
